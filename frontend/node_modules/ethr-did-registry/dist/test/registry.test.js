"use strict";
// noinspection DuplicatedCode
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = __importStar(require("chai"));
const chai_as_promised_1 = __importDefault(require("chai-as-promised"));
const utils_1 = require("ethers/lib/utils");
chai_1.default.use(chai_as_promised_1.default);
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { ethers } = require('hardhat');
describe('ERC1056', () => {
    let didReg;
    let identity; // = accounts[0];
    let identity2; // = accounts[1];
    let delegate; // = accounts[2];
    let delegate2; // = accounts[3];
    let delegate3; // = accounts[4];
    let badBoy; // = accounts[5];
    before(async () => {
        const Registry = await ethers.getContractFactory('EthereumDIDRegistry');
        didReg = await Registry.deploy();
        await didReg.deployed();
        [identity, identity2, delegate, delegate2, delegate3, badBoy] = await ethers.getSigners();
    });
    const privateKey = (0, utils_1.arrayify)('0xa285ab66393c5fdda46d6fbad9e27fafd438254ab72ad5acb681a0e9f20f5d7b');
    const signerAddress = '0x2036C6CD85692F0Fb2C26E6c6B2ECed9e4478Dfd';
    const privateKey2 = (0, utils_1.arrayify)('0xa285ab66393c5fdda46d6fbad9e27fafd438254ab72ad5acb681a0e9f20f5d7a');
    const signerAddress2 = '0xEA91e58E9Fa466786726F0a947e8583c7c5B3185';
    async function signData(identity, signerAddress, privateKeyBytes, dataBytes, nonce) {
        const _nonce = nonce || (await didReg.nonce(signerAddress));
        const paddedNonce = (0, utils_1.zeroPad)((0, utils_1.arrayify)(_nonce), 32);
        const dataToSign = (0, utils_1.hexConcat)(['0x1900', didReg.address, paddedNonce, identity, dataBytes]);
        const hash = (0, utils_1.keccak256)(dataToSign);
        return new utils_1.SigningKey(privateKeyBytes).signDigest(hash);
    }
    describe('identityOwner()', () => {
        describe('default owner', () => {
            it('should return the identity address itself', async () => {
                const owner = await didReg.identityOwner(identity2.address);
                (0, chai_1.expect)(owner).to.equal(identity2.address);
            });
        });
        describe('changed owner', () => {
            before(async () => {
                await didReg.connect(identity2).changeOwner(identity2.address, delegate.address);
            });
            it('should return the delegate address', async () => {
                const owner = await didReg.identityOwner(identity2.address);
                (0, chai_1.expect)(owner).to.equal(delegate.address);
            });
        });
    });
    describe('changeOwner()', () => {
        describe('using msg.sender', () => {
            describe('as current owner', () => {
                let tx;
                before(async () => {
                    tx = await didReg.connect(identity).changeOwner(identity.address, delegate.address);
                });
                it('should change owner mapping', async () => {
                    const owner = await didReg.owners(identity.address);
                    (0, chai_1.expect)(owner).to.equal(delegate.address);
                });
                it('should sets changed to transaction block', async () => {
                    const latest = await didReg.changed(identity.address);
                    (0, chai_1.expect)(latest).to.equal(tx.blockNumber);
                });
                it('should create DIDDelegateChanged event', async () => {
                    var _a;
                    const event = (_a = (await tx.wait()).events) === null || _a === void 0 ? void 0 : _a[0];
                    (0, chai_1.expect)(event.event).to.equal('DIDOwnerChanged');
                    (0, chai_1.expect)(event.args.identity).to.equal(identity.address);
                    (0, chai_1.expect)(event.args.owner).to.equal(delegate.address);
                    (0, chai_1.expect)(event.args.previousChange.toNumber()).to.equal(0);
                });
            });
            describe('as new owner', () => {
                let tx;
                let previousChange;
                before(async () => {
                    previousChange = (await didReg.changed(identity.address)).toNumber();
                    tx = await didReg.connect(delegate).changeOwner(identity.address, delegate2.address);
                });
                it('should change owner mapping', async () => {
                    const owner = await didReg.owners(identity.address);
                    (0, chai_1.expect)(owner).to.equal(delegate2.address);
                });
                it('should sets changed to transaction block', async () => {
                    const latest = await didReg.changed(identity.address);
                    (0, chai_1.expect)(latest).to.equal((await tx.wait()).blockNumber);
                });
                it('should create DIDOwnerChanged event', async () => {
                    var _a;
                    const event = (_a = (await tx.wait()).events) === null || _a === void 0 ? void 0 : _a[0];
                    (0, chai_1.expect)(event.event).to.equal('DIDOwnerChanged');
                    (0, chai_1.expect)(event.args.identity).to.equal(identity.address);
                    (0, chai_1.expect)(event.args.owner).to.equal(delegate2.address);
                    (0, chai_1.expect)(event.args.previousChange.toNumber()).to.equal(previousChange);
                });
            });
            describe('as original owner', () => {
                it('should fail', async () => {
                    await (0, chai_1.expect)(didReg.connect(identity).changeOwner(identity.address, identity.address)).to.be.rejectedWith(/bad_actor/);
                });
            });
            describe('as attacker', () => {
                it('should fail', async () => {
                    await (0, chai_1.expect)(didReg.connect(badBoy).changeOwner(identity.address, badBoy.address)).to.be.rejectedWith(/bad_actor/);
                });
            });
        });
        describe('using signature', () => {
            let tx;
            describe('as current owner', () => {
                before(async () => {
                    const sig = await signData(signerAddress, signerAddress, privateKey, (0, utils_1.concat)([(0, utils_1.toUtf8Bytes)('changeOwner'), signerAddress2]));
                    tx = await didReg.connect(badBoy).changeOwnerSigned(signerAddress, sig.v, sig.r, sig.s, signerAddress2);
                });
                it('should change owner mapping', async () => {
                    const owner2 = await didReg.owners(signerAddress);
                    (0, chai_1.expect)(owner2).to.equal(signerAddress2);
                });
                it('should sets changed to transaction block', async () => {
                    const latest = await didReg.changed(signerAddress);
                    (0, chai_1.expect)(latest).to.equal(tx.blockNumber);
                });
                it('should create DIDOwnerChanged event', async () => {
                    var _a;
                    const event = (_a = (await tx.wait()).events) === null || _a === void 0 ? void 0 : _a[0];
                    (0, chai_1.expect)(event.event).to.equal('DIDOwnerChanged');
                    (0, chai_1.expect)(event.args.identity).to.equal(signerAddress);
                    (0, chai_1.expect)(event.args.owner).to.equal(signerAddress2);
                    (0, chai_1.expect)(event.args.previousChange.toNumber()).to.equal(0);
                });
            });
            describe('as original owner', () => {
                it('should fail', async () => {
                    const sig = await signData(signerAddress, signerAddress, privateKey, (0, utils_1.concat)([(0, utils_1.toUtf8Bytes)('changeOwner'), signerAddress]));
                    await (0, chai_1.expect)(didReg.connect(badBoy).changeOwnerSigned(signerAddress, sig.v, sig.r, sig.s, signerAddress)).to.be.rejectedWith(/bad_signature/);
                });
            });
            describe('using wrong nonce', () => {
                it('should fail', async () => {
                    const currentNonce = (await didReg.nonce(signerAddress2)).toNumber();
                    (0, chai_1.expect)(currentNonce).to.equal(0);
                    const sig = await signData(signerAddress, signerAddress2, privateKey2, (0, utils_1.concat)([(0, utils_1.toUtf8Bytes)('changeOwner'), signerAddress2]), 1);
                    await (0, chai_1.expect)(didReg.connect(badBoy).changeOwnerSigned(signerAddress, sig.v, sig.r, sig.s, signerAddress2)).to.be.rejectedWith(/bad_signature/);
                });
            });
        });
    });
    describe('addDelegate()', () => {
        describe('using msg.sender', () => {
            it('validDelegate should be false', async () => {
                const valid = await didReg.validDelegate(identity.address, (0, utils_1.formatBytes32String)('attestor'), delegate3.address);
                (0, chai_1.expect)(valid).to.equal(false); // we have not yet assigned delegate correctly
            });
            describe('as current owner', () => {
                let tx;
                let block;
                let previousChange;
                before(async () => {
                    previousChange = (await didReg.changed(identity.address)).toNumber();
                    tx = await didReg
                        .connect(delegate2)
                        .addDelegate(identity.address, (0, utils_1.formatBytes32String)('attestor'), delegate3.address, 86400);
                    block = await ethers.provider.getBlock((await tx.wait()).blockNumber);
                });
                it('validDelegate should be true', async () => {
                    const valid = await didReg.validDelegate(identity.address, (0, utils_1.formatBytes32String)('attestor'), delegate3.address);
                    (0, chai_1.expect)(valid).to.equal(true); // assigned delegate correctly
                });
                it('should sets changed to transaction block', async () => {
                    const latest = await didReg.changed(identity.address);
                    (0, chai_1.expect)(latest).to.equal((await tx.wait()).blockNumber);
                });
                it('should create DIDDelegateChanged event', async () => {
                    var _a;
                    const event = (_a = (await tx.wait()).events) === null || _a === void 0 ? void 0 : _a[0];
                    (0, chai_1.expect)(event.event).to.equal('DIDDelegateChanged');
                    (0, chai_1.expect)(event.args.identity).to.equal(identity.address);
                    (0, chai_1.expect)((0, utils_1.parseBytes32String)(event.args.delegateType)).to.equal('attestor');
                    (0, chai_1.expect)(event.args.delegate).to.equal(delegate3.address);
                    (0, chai_1.expect)(event.args.validTo.toNumber()).to.equal(block.timestamp + 86400);
                    (0, chai_1.expect)(event.args.previousChange.toNumber()).to.equal(previousChange);
                });
            });
            describe('as original owner', () => {
                it('should fail', async () => {
                    const currentOwnerAddress = await didReg.owners(identity.address);
                    (0, chai_1.expect)(currentOwnerAddress).not.to.equal(identity.address);
                    await (0, chai_1.expect)(didReg
                        .connect(identity)
                        .addDelegate(identity.address, (0, utils_1.formatBytes32String)('attestor'), badBoy.address, 86400)).to.be.rejectedWith(/bad_actor/);
                });
            });
            describe('as attacker', () => {
                it('should fail', async () => {
                    await (0, chai_1.expect)(didReg.connect(badBoy).addDelegate(identity.address, (0, utils_1.formatBytes32String)('attestor'), badBoy.address, 86400)).to.be.rejectedWith(/bad_actor/);
                });
            });
        });
        describe('using signature', () => {
            describe('as current owner', () => {
                let tx;
                let block;
                let previousChange;
                before(async () => {
                    previousChange = (await didReg.changed(signerAddress)).toNumber();
                    const sig = await signData(signerAddress, signerAddress2, privateKey2, (0, utils_1.concat)([
                        (0, utils_1.toUtf8Bytes)('addDelegate'),
                        (0, utils_1.formatBytes32String)('attestor'),
                        delegate.address,
                        (0, utils_1.zeroPad)((0, utils_1.hexlify)(86400), 32),
                    ]));
                    tx = await didReg
                        .connect(badBoy)
                        .addDelegateSigned(signerAddress, sig.v, sig.r, sig.s, (0, utils_1.formatBytes32String)('attestor'), delegate.address, 86400);
                    block = await ethers.provider.getBlock((await tx.wait()).blockNumber);
                });
                it('validDelegate should be true', async () => {
                    const valid = await didReg.validDelegate(signerAddress, (0, utils_1.formatBytes32String)('attestor'), delegate.address);
                    (0, chai_1.expect)(valid).to.equal(true); // assigned delegate correctly
                });
                it('should sets changed to transaction block', async () => {
                    const latest = await didReg.changed(signerAddress);
                    (0, chai_1.expect)(latest.toNumber()).to.equal((await tx.wait()).blockNumber);
                });
                it('should create DIDDelegateChanged event', async () => {
                    var _a;
                    const event = (_a = (await tx.wait()).events) === null || _a === void 0 ? void 0 : _a[0];
                    (0, chai_1.expect)(event.event).to.equal('DIDDelegateChanged');
                    (0, chai_1.expect)(event.args.identity).to.equal(signerAddress);
                    (0, chai_1.expect)((0, utils_1.parseBytes32String)(event.args.delegateType), 'attestor');
                    (0, chai_1.expect)(event.args.delegate).to.equal(delegate.address);
                    (0, chai_1.expect)(event.args.validTo.toNumber()).to.equal(block.timestamp + 86400);
                    (0, chai_1.expect)(event.args.previousChange.toNumber()).to.equal(previousChange);
                });
            });
            describe('as wrong owner', () => {
                it('should fail', async () => {
                    const sig = await signData(signerAddress, signerAddress, privateKey, (0, utils_1.concat)([
                        (0, utils_1.toUtf8Bytes)('addDelegate'),
                        (0, utils_1.formatBytes32String)('attestor'),
                        delegate.address,
                        (0, utils_1.zeroPad)((0, utils_1.hexlify)(86400), 32),
                    ]));
                    await (0, chai_1.expect)(didReg
                        .connect(badBoy)
                        .addDelegateSigned(signerAddress, sig.v, sig.r, sig.s, (0, utils_1.formatBytes32String)('attestor'), delegate.address, 86400)).to.be.rejectedWith(/bad_signature/);
                });
            });
            describe('using wrong nonce', () => {
                it('should fail', async () => {
                    const currentNonce = (await didReg.nonce(signerAddress2)).toNumber();
                    (0, chai_1.expect)(currentNonce).to.equal(1);
                    const sig = await signData(signerAddress, signerAddress2, privateKey2, (0, utils_1.concat)([
                        (0, utils_1.toUtf8Bytes)('addDelegate'),
                        (0, utils_1.formatBytes32String)('attestor'),
                        delegate.address,
                        (0, utils_1.zeroPad)((0, utils_1.hexlify)(86400), 32),
                    ]), 2);
                    await (0, chai_1.expect)(didReg
                        .connect(badBoy)
                        .addDelegateSigned(signerAddress, sig.v, sig.r, sig.s, (0, utils_1.formatBytes32String)('attestor'), delegate.address, 86400)).to.be.rejectedWith(/bad_signature/);
                });
            });
        });
    });
    describe('revokeDelegate()', () => {
        describe('using msg.sender', () => {
            it('validDelegate should be true', async () => {
                const valid = await didReg.validDelegate(identity.address, (0, utils_1.formatBytes32String)('attestor'), delegate3.address);
                (0, chai_1.expect)(valid).to.equal(true); // not yet revoked
            });
            describe('as current owner', () => {
                let tx;
                let previousChange;
                before(async () => {
                    previousChange = (await didReg.changed(identity.address)).toNumber();
                    tx = await didReg
                        .connect(delegate2)
                        .revokeDelegate(identity.address, (0, utils_1.formatBytes32String)('attestor'), delegate3.address);
                });
                it('validDelegate should be false', async () => {
                    const valid = await didReg.validDelegate(identity.address, (0, utils_1.formatBytes32String)('attestor'), delegate3.address);
                    (0, chai_1.expect)(valid).to.equal(false); // revoked correctly
                });
                it('should sets changed to transaction block', async () => {
                    const latest = await didReg.changed(identity.address);
                    (0, chai_1.expect)(latest).to.equal((await tx.wait()).blockNumber);
                });
                it('should create DIDDelegateChanged event', async () => {
                    var _a;
                    const event = (_a = (await tx.wait()).events) === null || _a === void 0 ? void 0 : _a[0];
                    (0, chai_1.expect)(event.event).to.equal('DIDDelegateChanged');
                    (0, chai_1.expect)(event.args.identity).to.equal(identity.address);
                    (0, chai_1.expect)((0, utils_1.parseBytes32String)(event.args.delegateType)).to.equal('attestor');
                    (0, chai_1.expect)(event.args.delegate).to.equal(delegate3.address);
                    (0, chai_1.expect)(event.args.validTo.toNumber()).to.be.lessThanOrEqual((await ethers.provider.getBlock(tx.blockNumber)).timestamp);
                    (0, chai_1.expect)(event.args.previousChange.toNumber()).to.equal(previousChange);
                });
            });
            describe('as original owner', () => {
                it('should fail', async () => {
                    const currentOwnerAddress = await didReg.owners(identity.address);
                    (0, chai_1.expect)(currentOwnerAddress).not.to.equal(identity.address);
                    await (0, chai_1.expect)(didReg.connect(identity).revokeDelegate(identity.address, (0, utils_1.formatBytes32String)('attestor'), badBoy.address)).to.be.rejectedWith(/bad_actor/);
                });
            });
            describe('as attacker', () => {
                it('should fail', async () => {
                    await (0, chai_1.expect)(didReg.connect(badBoy).revokeDelegate(identity.address, (0, utils_1.formatBytes32String)('attestor'), badBoy.address)).to.be.revertedWith('bad_actor');
                });
            });
        });
        describe('using signature', () => {
            describe('as current owner', () => {
                let tx;
                let previousChange;
                before(async () => {
                    previousChange = (await didReg.changed(signerAddress)).toNumber();
                    const sig = await signData(signerAddress, signerAddress2, privateKey2, (0, utils_1.concat)([(0, utils_1.toUtf8Bytes)('revokeDelegate'), (0, utils_1.formatBytes32String)('attestor'), delegate.address]));
                    tx = await didReg
                        .connect(badBoy)
                        .revokeDelegateSigned(signerAddress, sig.v, sig.r, sig.s, (0, utils_1.formatBytes32String)('attestor'), delegate.address);
                });
                it('validDelegate should be false', async () => {
                    const valid = await didReg.validDelegate(signerAddress, (0, utils_1.formatBytes32String)('attestor'), delegate.address);
                    (0, chai_1.expect)(valid).to.equal(false); // revoked delegate correctly
                });
                it('should sets changed to transaction block', async () => {
                    const latest = await didReg.changed(signerAddress);
                    (0, chai_1.expect)(latest).to.equal((await tx.wait()).blockNumber);
                });
                it('should create DIDDelegateChanged event', async () => {
                    var _a;
                    const event = (_a = (await tx.wait()).events) === null || _a === void 0 ? void 0 : _a[0];
                    (0, chai_1.expect)(event.event).to.equal('DIDDelegateChanged');
                    (0, chai_1.expect)(event.args.identity).to.equal(signerAddress);
                    (0, chai_1.expect)((0, utils_1.parseBytes32String)(event.args.delegateType)).to.equal('attestor');
                    (0, chai_1.expect)(event.args.delegate).to.equal(delegate.address);
                    (0, chai_1.expect)(event.args.validTo.toNumber()).to.be.lessThanOrEqual((await ethers.provider.getBlock(tx.blockNumber)).timestamp);
                    (0, chai_1.expect)(event.args.previousChange.toNumber()).to.equal(previousChange);
                });
            });
            describe('as wrong owner', () => {
                it('should fail', async () => {
                    const sig = await signData(signerAddress, signerAddress, privateKey, (0, utils_1.concat)([(0, utils_1.toUtf8Bytes)('revokeDelegate'), (0, utils_1.formatBytes32String)('attestor'), delegate.address]));
                    await (0, chai_1.expect)(didReg
                        .connect(badBoy)
                        .revokeDelegateSigned(signerAddress, sig.v, sig.r, sig.s, (0, utils_1.formatBytes32String)('attestor'), delegate.address)).to.be.rejectedWith(/bad_signature/);
                });
            });
            describe('using wrong nonce', () => {
                it('should fail', async () => {
                    const currentNonce = (await didReg.nonce(signerAddress2)).toNumber();
                    (0, chai_1.expect)(currentNonce).to.equal(2);
                    const sig = await signData(signerAddress, signerAddress2, privateKey2, (0, utils_1.concat)([(0, utils_1.toUtf8Bytes)('revokeDelegate'), (0, utils_1.formatBytes32String)('attestor'), delegate.address]), 1);
                    await (0, chai_1.expect)(didReg
                        .connect(badBoy)
                        .revokeDelegateSigned(signerAddress, sig.v, sig.r, sig.s, (0, utils_1.formatBytes32String)('attestor'), delegate.address)).to.be.rejectedWith(/bad_signature/);
                });
            });
        });
    });
    describe('setAttribute()', () => {
        describe('using msg.sender', () => {
            describe('as current owner', () => {
                let tx;
                let block;
                let previousChange;
                before(async () => {
                    previousChange = (await didReg.changed(identity.address)).toNumber();
                    const currentOwnerAddress = await didReg.owners(identity.address);
                    const signer = (await ethers.getSigners()).find((signer) => signer.address === currentOwnerAddress);
                    tx = await didReg
                        .connect(signer)
                        .setAttribute(identity.address, (0, utils_1.formatBytes32String)('encryptionKey'), (0, utils_1.toUtf8Bytes)('mykey'), 86400);
                    block = await ethers.provider.getBlock((await tx.wait()).blockNumber);
                });
                it('should sets changed to transaction block', async () => {
                    const latest = await didReg.changed(identity.address);
                    (0, chai_1.expect)(latest).to.equal((await tx.wait()).blockNumber);
                });
                it('should create DIDAttributeChanged event', async () => {
                    var _a;
                    const event = (_a = (await tx.wait()).events) === null || _a === void 0 ? void 0 : _a[0];
                    (0, chai_1.expect)(event.event).to.equal('DIDAttributeChanged');
                    (0, chai_1.expect)(event.args.identity).to.equal(identity.address);
                    (0, chai_1.expect)((0, utils_1.parseBytes32String)(event.args.name)).to.equal('encryptionKey');
                    (0, chai_1.expect)(event.args.value).to.equal('0x6d796b6579'); // the hex encoding of the string "mykey"
                    (0, chai_1.expect)(event.args.validTo.toNumber()).to.equal(block.timestamp + 86400);
                    (0, chai_1.expect)(event.args.previousChange.toNumber()).to.equal(previousChange);
                });
            });
            describe('as original owner', () => {
                it('should fail', async () => {
                    const currentOwnerAddress = await didReg.owners(identity.address);
                    (0, chai_1.expect)(currentOwnerAddress).not.to.equal(identity.address);
                    await (0, chai_1.expect)(didReg
                        .connect(identity)
                        .setAttribute(identity.address, (0, utils_1.formatBytes32String)('encryptionKey'), (0, utils_1.toUtf8Bytes)('mykey'), 86400)).to.be.rejectedWith(/bad_actor/);
                });
            });
            describe('as attacker', () => {
                it('should fail', async () => {
                    await (0, chai_1.expect)(didReg
                        .connect(badBoy)
                        .setAttribute(identity.address, (0, utils_1.formatBytes32String)('encryptionKey'), (0, utils_1.toUtf8Bytes)('mykey'), 86400)).to.be.rejectedWith(/bad_actor/);
                });
            });
        });
        describe('using signature', () => {
            describe('as current owner', () => {
                let tx;
                let block;
                let previousChange;
                before(async () => {
                    previousChange = (await didReg.changed(signerAddress)).toNumber();
                    const sig = await signData(signerAddress, signerAddress2, privateKey2, (0, utils_1.concat)([
                        (0, utils_1.toUtf8Bytes)('setAttribute'),
                        (0, utils_1.formatBytes32String)('encryptionKey'),
                        (0, utils_1.toUtf8Bytes)('mykey'),
                        (0, utils_1.zeroPad)((0, utils_1.hexlify)(86400), 32),
                    ]));
                    tx = await didReg
                        .connect(badBoy)
                        .setAttributeSigned(signerAddress, sig.v, sig.r, sig.s, (0, utils_1.formatBytes32String)('encryptionKey'), (0, utils_1.toUtf8Bytes)('mykey'), 86400);
                    block = await ethers.provider.getBlock((await tx.wait()).blockNumber);
                });
                it('should sets changed to transaction block', async () => {
                    const latest = await didReg.changed(signerAddress);
                    (0, chai_1.expect)(latest).to.equal((await tx.wait()).blockNumber);
                });
                it('should create DIDDelegateChanged event', async () => {
                    var _a;
                    const event = (_a = (await tx.wait()).events) === null || _a === void 0 ? void 0 : _a[0];
                    (0, chai_1.expect)(event.event).to.equal('DIDAttributeChanged');
                    (0, chai_1.expect)(event.args.identity).to.equal(signerAddress);
                    (0, chai_1.expect)((0, utils_1.parseBytes32String)(event.args.name)).to.equal('encryptionKey');
                    (0, chai_1.expect)(event.args.value).to.equal('0x6d796b6579'); // the hex encoding of the string "mykey"
                    (0, chai_1.expect)(event.args.validTo.toNumber()).to.equal(block.timestamp + 86400);
                    (0, chai_1.expect)(event.args.previousChange.toNumber()).to.equal(previousChange);
                });
            });
            describe('as wrong owner', () => {
                it('should fail', async () => {
                    const sig = await signData(signerAddress, signerAddress, privateKey, (0, utils_1.concat)([
                        (0, utils_1.toUtf8Bytes)('setAttribute'),
                        (0, utils_1.formatBytes32String)('encryptionKey'),
                        (0, utils_1.toUtf8Bytes)('mykey'),
                        (0, utils_1.zeroPad)((0, utils_1.hexlify)(86400), 32),
                    ]));
                    await (0, chai_1.expect)(didReg
                        .connect(badBoy)
                        .setAttributeSigned(signerAddress, sig.v, sig.r, sig.s, (0, utils_1.formatBytes32String)('encryptionKey'), (0, utils_1.toUtf8Bytes)('mykey'), 86400)).to.be.rejectedWith(/bad_signature/);
                });
            });
            describe('using wrong nonce', () => {
                it('should fail', async () => {
                    const currentNonce = (await didReg.nonce(signerAddress2)).toNumber();
                    (0, chai_1.expect)(currentNonce).to.equal(3);
                    const sig = await signData(signerAddress, signerAddress2, privateKey2, (0, utils_1.concat)([
                        (0, utils_1.toUtf8Bytes)('setAttribute'),
                        (0, utils_1.formatBytes32String)('encryptionKey'),
                        (0, utils_1.toUtf8Bytes)('mykey'),
                        (0, utils_1.zeroPad)((0, utils_1.hexlify)(86400), 32),
                    ]), 1);
                    await (0, chai_1.expect)(didReg
                        .connect(badBoy)
                        .setAttributeSigned(signerAddress, sig.v, sig.r, sig.s, (0, utils_1.formatBytes32String)('encryptionKey'), (0, utils_1.toUtf8Bytes)('mykey'), 86400)).to.be.rejectedWith(/bad_signature/);
                });
            });
        });
    });
    describe('revokeAttribute()', () => {
        describe('using msg.sender', () => {
            describe('as current owner', () => {
                let tx;
                let previousChange;
                before(async () => {
                    previousChange = (await didReg.changed(identity.address)).toNumber();
                    const currentOwnerAddress = await didReg.owners(identity.address);
                    const signer = (await ethers.getSigners()).find((signer) => signer.address === currentOwnerAddress);
                    tx = await didReg
                        .connect(signer)
                        .revokeAttribute(identity.address, (0, utils_1.formatBytes32String)('encryptionKey'), (0, utils_1.toUtf8Bytes)('mykey'));
                });
                it('should sets changed to transaction block', async () => {
                    const latest = await didReg.changed(identity.address);
                    (0, chai_1.expect)(latest).to.equal((await tx.wait()).blockNumber);
                });
                it('should create DIDAttributeChanged event', async () => {
                    var _a;
                    const event = (_a = (await tx.wait()).events) === null || _a === void 0 ? void 0 : _a[0];
                    (0, chai_1.expect)(event.event).to.equal('DIDAttributeChanged');
                    (0, chai_1.expect)(event.args.identity).to.equal(identity.address);
                    (0, chai_1.expect)((0, utils_1.parseBytes32String)(event.args.name)).to.equal('encryptionKey');
                    (0, chai_1.expect)(event.args.value).to.equal('0x6d796b6579'); // hex encoding of the string "mykey"
                    (0, chai_1.expect)(event.args.validTo.toNumber()).to.equal(0);
                    (0, chai_1.expect)(event.args.previousChange.toNumber()).to.equal(previousChange);
                });
            });
            describe('as original owner', () => {
                it('should fail', async () => {
                    const currentOwnerAddress = await didReg.owners(identity.address);
                    (0, chai_1.expect)(currentOwnerAddress).not.to.equal(identity.address);
                    await (0, chai_1.expect)(didReg
                        .connect(identity)
                        .revokeAttribute(identity.address, (0, utils_1.formatBytes32String)('encryptionKey'), (0, utils_1.toUtf8Bytes)('mykey'))).to.be.rejectedWith(/bad_actor/);
                });
            });
            describe('as attacker', () => {
                it('should fail', async () => {
                    await (0, chai_1.expect)(didReg
                        .connect(badBoy)
                        .revokeAttribute(identity.address, (0, utils_1.formatBytes32String)('encryptionKey'), (0, utils_1.toUtf8Bytes)('mykey'))).to.be.rejectedWith(/bad_actor/);
                });
            });
        });
        describe('using signature', () => {
            describe('as current owner', () => {
                let tx;
                let previousChange;
                before(async () => {
                    previousChange = (await didReg.changed(signerAddress)).toNumber();
                    const sig = await signData(signerAddress, signerAddress2, privateKey2, (0, utils_1.concat)([(0, utils_1.toUtf8Bytes)('revokeAttribute'), (0, utils_1.formatBytes32String)('encryptionKey'), (0, utils_1.toUtf8Bytes)('mykey')]));
                    tx = await didReg
                        .connect(badBoy)
                        .revokeAttributeSigned(signerAddress, sig.v, sig.r, sig.s, (0, utils_1.formatBytes32String)('encryptionKey'), (0, utils_1.toUtf8Bytes)('mykey'));
                });
                it('should sets changed to transaction block', async () => {
                    const latest = await didReg.changed(signerAddress);
                    (0, chai_1.expect)(latest).to.equal((await tx.wait()).blockNumber);
                });
                it('should create DIDDelegateChanged event', async () => {
                    var _a;
                    const event = (_a = (await tx.wait()).events) === null || _a === void 0 ? void 0 : _a[0];
                    (0, chai_1.expect)(event.event).to.equal('DIDAttributeChanged');
                    (0, chai_1.expect)(event.args.identity).to.equal(signerAddress);
                    (0, chai_1.expect)((0, utils_1.parseBytes32String)(event.args.name)).to.equal('encryptionKey');
                    (0, chai_1.expect)(event.args.value).to.equal('0x6d796b6579'); // hex encoding of the string "mykey"
                    (0, chai_1.expect)(event.args.validTo.toNumber()).to.equal(0);
                    (0, chai_1.expect)(event.args.previousChange.toNumber()).to.equal(previousChange);
                });
            });
            describe('as wrong owner', () => {
                it('should fail', async () => {
                    const sig = await signData(signerAddress, signerAddress, privateKey, (0, utils_1.concat)([(0, utils_1.toUtf8Bytes)('revokeAttribute'), (0, utils_1.formatBytes32String)('encryptionKey'), (0, utils_1.toUtf8Bytes)('mykey')]));
                    await (0, chai_1.expect)(didReg
                        .connect(badBoy)
                        .revokeAttributeSigned(signerAddress, sig.v, sig.r, sig.s, (0, utils_1.formatBytes32String)('encryptionKey'), (0, utils_1.toUtf8Bytes)('mykey'))).to.be.rejectedWith(/bad_signature/);
                });
            });
            describe('using wrong nonce', () => {
                it('should fail', async () => {
                    const currentNonce = (await didReg.nonce(signerAddress2)).toNumber();
                    (0, chai_1.expect)(currentNonce).to.equal(4);
                    const sig = await signData(signerAddress, signerAddress2, privateKey2, (0, utils_1.concat)([(0, utils_1.toUtf8Bytes)('revokeAttribute'), (0, utils_1.formatBytes32String)('encryptionKey'), (0, utils_1.toUtf8Bytes)('mykey')]), 1);
                    await (0, chai_1.expect)(didReg
                        .connect(badBoy)
                        .revokeAttributeSigned(signerAddress, sig.v, sig.r, sig.s, (0, utils_1.formatBytes32String)('encryptionKey'), (0, utils_1.toUtf8Bytes)('mykey'))).to.be.rejectedWith(/bad_signature/);
                });
            });
        });
    });
    describe('Events', () => {
        it('can create list', async () => {
            const history = [];
            let prevChange = (await didReg.changed(identity.address)).toNumber();
            while (prevChange) {
                const logs = await ethers.provider.getLogs({
                    topics: [null, (0, utils_1.hexZeroPad)(identity.address, 32)],
                    fromBlock: prevChange,
                    toBlock: prevChange,
                });
                prevChange = 0;
                for (const log of logs) {
                    const logDescription = didReg.interface.parseLog(log);
                    history.unshift(logDescription.name);
                    prevChange = logDescription.args.previousChange.toNumber();
                }
            }
            (0, chai_1.expect)(history).to.deep.equal([
                'DIDOwnerChanged',
                'DIDOwnerChanged',
                'DIDDelegateChanged',
                'DIDDelegateChanged',
                'DIDAttributeChanged',
                'DIDAttributeChanged',
            ]);
        });
    });
});
